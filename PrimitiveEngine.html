<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rasmus Göransson - Primitive Engine</title>
    <link rel="stylesheet" href="output.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;400;600;700&display=swap">

    <link rel="stylesheet" href="../ScriptStyle/prism-vsc-dark-plus.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-csharp.min.js"></script>
</head>

<body class="bg-zinc-800 text-white font-exo2">
    
   <header>
        <div>
            <nav>
                <ul class="flex text-center justify-center pt-4">
                    <li><a href="index.html" class="nav-link text-xl">HOME</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="container mx-auto px-4 py-8 text-white">

        <div id="top" class="flex flex-col md:flex-row md:space-x-8">
            <!-- PRIMITIVE ENGINE -->
            <section class="md:w-2/3 bg-zinc-900 bg-opacity-90 p-4 rounded-md text-lg leading-8">
                <h2 class="text-4xl font-semibold mb-4 text-green-500">Primitive Engine</h2>
                <p class="py-4">
                    Primitive Engine is a project I started to improve my C++ skills.
                    <br>
                    <br>
                    I decided to use SDL2 instead of a normal game engine. My main focus with this project is C++, but, I also thought it would be fun to try working with something I hadn't before.
                    SDL2 is used for window management and rendering. For math I use GLM.
                    <br>
                    <br>
                    This project is a work in progress, and I have more features planned. 
                    So far, I've mainly focused on creating a foundation for the project, adding features like collision and player movement.
                </p>
            </section>

            <!-- Game Plan -->
            <aside class="md:w-1/3 bg-zinc-900 bg-opacity-90 p-4 my-8 md:my-0 rounded-md">
                <h2 class="text-3xl font-semibold mb-4 text-center text-green-500">Game Plan</h2>
                <div class="text-lg leading-8 py-2">
                    <p>
                        My plan for this project is to create a game similar to Terraria, a 2D block game. The main features would be:
                        <p>
                            - Building
                            <br>
                            - Mining
                            <br>
                            - Combat
                        </p>
                        A final feature I aim to explore is procedural world generation.
                    </p>
            </aside>
        </div>

        <!-- Code Navigation Buttons-->
        <div class="navigation-bar">
            <button class="code-navigation-button text-2xl" onclick="scrollToElement('top')">↑</button>
            <button class="code-navigation-button" onclick="scrollToElement('game-code-text')">GAME</button>
            <button class="code-navigation-button" onclick="scrollToElement('input-code-text')">INPUT MANAGER</button>
            <button class="code-navigation-button" onclick="scrollToElement('texture-code-text')">TEXTURE MANAGER</button>
            <button class="code-navigation-button" onclick="scrollToElement('collision-code-text')">COLLISION</button>
            <button class="code-navigation-button" onclick="scrollToElement('camera-code-text')">CAMERA</button>
            <button class="code-navigation-button" onclick="scrollToElement('player-code-text')">PLAYER</button>
            <button class="code-navigation-button" onclick="scrollToElement('block-code-text')">BLOCK</button>

        </div>

        <!-- DIVIDER -->
        <div class="divider"></div>

        <div class="code-container">
            <!-- GAME CLASS CODE -->
            <section class="code-example-section">
                
                <div class="flex justify-evenly">
                    <button
                    id="toggle-game-code-header"
                    class="toggleButton text-xl text-green-500"
                    onclick="enableElement('game-code-header', 'toggle-game-code-header'); disableElement('game-code-cpp', 'toggle-game-code-cpp');">
                    HEADER
                    </button>
                    <button
                    id="toggle-game-code-cpp"
                    class="toggleButton text-xl"
                    onclick="enableElement('game-code-cpp', 'toggle-game-code-cpp'); disableElement('game-code-header', 'toggle-game-code-header');">
                    C++
                    </button>
                </div>

                <button 
                class="toggleButton absolute top-20 right-10"
                onclick="toggleOverflow('game-code-example-header'); toggleOverflow('game-code-example-cpp');">
                ⇅
                </button>

                <div id="game-code-header" class="">
                    <pre id="game-code-example-header" class="code-example-preview h-80">
                        <code class="language-csharp">
#pragma once

#include "iostream"
#include "SDL_image.h"
#include "SDL.h"
#include "vector"

#define NOMINMAX
#include "windows.h"

static constexpr int max_Actors = 50;

// Forward declarations
class Actor;
enum class ECollision_Type;
class Camera;
class WorldGenerator;

class Game {

public:

	Game(const Game&) = delete;
	Game& operator=(const Game&) = delete;

	static Game& Instance()
	{
		static Game instance;
		return instance;
	}


	void Init(const char* title, int xPos, int yPos, int width, int height, bool fullscreen);

	void HandleEvents();

	void Update();

	void Render();


	void Clean();

	bool Running() { return isRunning; }

	void SetRenderColor();
	void FillRenderRect(int x, int y, int width, int height);
	void RenderRect(int x, int y, int width, int height);

	Actor* GetCollidingActor(Actor* other, ECollision_Type collisionType);
	std::vector&lt;Actor*&gt; GetAllCollidingActors(Actor* other, ECollision_Type collisionType);

	SDL_Renderer* GetRenderer();

	// getter functions
	Actor* GetPlayer();
	Camera* GetCamera();
	WorldGenerator* GetWorldGenerator();

private:

	Game();
	~Game();

	SDL_Window* window;
	SDL_Renderer* renderer;

	bool isRunning;

	static constexpr float BACKGROUND_GRID_SIZE = 50.f;

	Actor* actors[max_Actors] = { nullptr };


	WorldGenerator* worldGenerator = nullptr;


	Actor* player = nullptr;

	Camera* camera = nullptr;

};


// game time
float Get_DeltaTime();

float Get_CurrentTime();

float Get_TimePassedSince(float time);

int GetFrameCount();


                        </code>
                    </pre>
                </div>

                <div id="game-code-cpp" class="hidden">
                    <pre id="game-code-example-cpp" class="code-example-preview h-80">
                        <code class="language-csharp">
#include "Game.h"
#include "Player.h"
#include "Camera.h"
#include "glm.hpp"
#include "InputManager.h"
#include "WorldGenerator.h"
#include "AABB.h"
#include "TextureManager.h"

static float deltaTime = 0.f;
static unsigned int frameCount = 0;


// time
static LARGE_INTEGER clockFrequency;
static LARGE_INTEGER lastFrameTime;
static LARGE_INTEGER startupTime;

Game::Game()
{
    worldGenerator = new WorldGenerator();
    
    actors[0] = new Player(glm::vec2(32, -32));
    player = actors[0];


    camera = new Camera();
}

Game::~Game() // DELETE POINTERS
{
    delete player;

    delete camera;
}

void Game::Init(const char* title, int xPos, int yPos, int width, int height, bool fullscreen)
{
    int flags = 0;
    if (fullscreen)
    {
        flags = SDL_WINDOW_FULLSCREEN;
    }

    if (SDL_Init(SDL_INIT_EVERYTHING) == 0)
    {
        // initialize window
        window = SDL_CreateWindow(title, xPos, yPos, width, height, flags);
        if (window)
        {
            std::cout &lt;&lt; "Window created!" &lt;&lt; std::endl;
        }


        // initialize renderer
        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
        if (renderer)
        {
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
            std::cout &lt;&lt; "Renderer Created!" &lt;&lt; std::endl;
        }


        // initialize clock for delta time calc
        QueryPerformanceFrequency(&clockFrequency);
        QueryPerformanceCounter(&startupTime);
        lastFrameTime = startupTime;

        isRunning = true;
    }
    else
    {
        isRunning = false;
    }

    TextureManager::Instance().Load("player", "Textures/player.png", renderer);
    TextureManager::Instance().Load("block_dirt", "Textures/block_dirt.png", renderer);
}

void Game::HandleEvents()
{
    SDL_Event event;
    SDL_PollEvent(&event);
    
    switch (event.type)
    {
        case SDL_QUIT:
        {
            isRunning = false;
            break;
        }
    }
    
    InputManager::Instance().HandleEvents(event);
}

void Game::Update()
{
    LARGE_INTEGER currentFrameTime;
    QueryPerformanceCounter(&currentFrameTime);
    deltaTime = float(currentFrameTime.QuadPart - lastFrameTime.QuadPart) / clockFrequency.QuadPart;

    lastFrameTime = currentFrameTime;

    if (player != nullptr)
    {
        player->Update();
    }

    for (int x = 0; x &lt; worldGenerator->WORLD_WIDTH; x++)
    {
        for (int y = 0; y &lt; worldGenerator->WORLD_HEIGHT; y++)
        {
            Block* block = worldGenerator->worldGrid[x][y];

            if (block != nullptr)
            {
                block->Update();
            }
        }
    }


    camera->Update();

    // last thing in update
    frameCount++;
}

void Game::Render()
{
    // clear screen
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // background grid
    for (int x = -50; x &lt;= 50; x++)
    {
        for (int y = -50; y &lt;= 50; y++)
        {
            if ((x + y) % 2 == 0)
            {
                SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
            }
            else
            {
                SDL_SetRenderDrawColor(renderer, 150, 150, 150, 255);
            }

            glm::vec2 position = glm::vec2(x * BACKGROUND_GRID_SIZE, y * BACKGROUND_GRID_SIZE);
            position = camera->WorldToScreen(position);

            SDL_Rect rect = { position.x, position.y, BACKGROUND_GRID_SIZE, BACKGROUND_GRID_SIZE };
            SDL_RenderFillRect(renderer, &rect);
        }
    }

    if (worldGenerator->worldGrid != nullptr)
    {
        for (int x = 0; x &lt; worldGenerator->WORLD_WIDTH; x++)
        {
            for (int y = 0; y &lt; worldGenerator->WORLD_HEIGHT; y++)
            {
                if (worldGenerator->worldGrid[x][y] != nullptr)
                {
                    worldGenerator->worldGrid[x][y]->Render();
                }
            }
        }
    }

    if (player != nullptr)
    {
        player->Render();
    }

    SDL_RenderPresent(renderer);
}

void Game::Clean()
{
    TextureManager::Instance().Clean();

    SDL_DestroyWindow(window);
    SDL_DestroyRenderer(renderer);
    SDL_Quit();
    std::cout &lt;&lt; "Game Cleaned" &lt;&lt; std::endl;
}


void Game::SetRenderColor()
{
    // white color
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
}

void Game::FillRenderRect(int x, int y, int width, int height)
{
    SDL_Rect rect = { x, y, width, height };
    SDL_RenderFillRect(renderer, &rect);
}

void Game::RenderRect(int x, int y, int width, int height)
{
    SDL_SetRenderDrawColor(renderer, 10, 10, 10, 255);
    SDL_Rect rect = { x, y, width, height };
    SDL_RenderDrawRect(renderer, &rect);
}

Actor* Game::GetCollidingActor(Actor* actor, ECollision_Type collisionType)
{
    for (int i = 0; i &lt; max_Actors; i++)
    {
        if (actors[i] == actor)
            continue;

        if (actors[i] == nullptr)
            continue;

        if (actors[i]->collisionType != collisionType)
            continue;

        AABB a = AABB::FromPositionSize(actor->position, actor->size);
        AABB b = AABB::FromPositionSize(actors[i]->position, actors[i]->size);

        if (aabbOverlap(a, b))
        {
            return actors[i];
        }
    }
    
    return nullptr;
}

std::vector&lt;Actor*&gt; Game::GetAllCollidingActors(Actor* actor, ECollision_Type collisionType)
{
    std::vector&lt;Actor*&gt; collidingActors;
    collidingActors.clear();

    if (worldGenerator->worldGrid != nullptr)
    {
        for (int x = 0; x &lt; worldGenerator->WORLD_WIDTH; x++)
        {
            for (int y = 0; y &lt; worldGenerator->WORLD_HEIGHT; y++)
            {
                Block* block = worldGenerator->worldGrid[x][y];

                if (block == nullptr)
                    continue;

                if (block->collisionType != collisionType)
                    continue;

                AABB a = AABB::FromPositionSize(actor->position, actor->size);
                AABB b = AABB::FromPositionSize(block->position, block->size);

                if (aabbOverlap(a, b))
                {
                    collidingActors.push_back(block);
                }
            }
        }
    }

    return collidingActors;
}

SDL_Renderer* Game::GetRenderer()
{
    return renderer;
}


Actor* Game::GetPlayer()
{
    return player;
}

Camera* Game::GetCamera()
{
    return camera;
}

WorldGenerator* Game::GetWorldGenerator()
{
    return worldGenerator;
}


float Get_DeltaTime()
{
    return deltaTime;
}

float Get_CurrentTime()
{
    return float(lastFrameTime.QuadPart - startupTime.QuadPart) / clockFrequency.QuadPart;
}

float Get_TimePassedSince(float time)
{
    return Get_CurrentTime() - time;
}

int GetFrameCount()
{
    return frameCount;
}
                        </code>
                    </pre>
                </div>

            </section>

            <!-- GAME CLASS CODE TEXT -->
            <aside id="game-code-text" class="code-text-section">
                <h2 class="code-text-heading mt-0 md:mt-8">GAME CLASS</h2>
                <p class="leading-8">
                    The Game class is the core of the engine, it handles:
                    <p>
                        <span class="font-bold">Initialization -</span>
                        <span class="italic">Sets up the game window, renderer and loads textures.</span>
                        <br>
                        <span class="font-bold">Event handling -</span>
                        <span class="italic">Processes player input events and quit requests.</span>
                        <br>
                        <span class="font-bold">Game loop -</span>
                        <span class="italic">Updates the game state and renders visuals.</span>
                        <br>
                        <span class="font-bold">Time management -</span>
                        <span class="italic">Tracks time, framecount and calculates delta time.</span>
                        <br>
                        <span class="font-bold">Cleanup</span>
                        <span class="italic">Properly shuts down the game and prevents memory leaks.</span>
                    </p>
                </p>
            </aside>    
        </div>

        <!-- DIVIDER -->
        <div class="divider"></div>

        <div class="code-container">
            <!-- INPUT MANAGER CODE TEXT -->
            <section id="input-code-text" class="code-text-section">
                <h2 class="code-text-heading mt-0 md:mt-8">INPUT MANAGER</h2>
                <p class="leading-8">
                    The InputManager handles keyboard and mouse input using SDL events.
                    <br>
                    Tracks the different key and mouse button states:
                    <p>
                        <span class="italic">- Pressed</span>
                        <br>
                        <span class="italic">- Held</span>
                        <br>
                        <span class="italic">- Released</span>
                    </p>
                    It also tracks the mouse position.
                    <br>
                    All inputs are frame-accurate, ensuring accurate and responsive input handling.
                </p>
            </section>

            <!-- INPUT MANAGER CODE -->
            <aside class="code-example-section">
                
                <div class="flex justify-evenly">
                    <button
                    id="toggle-input-code-header"
                    class="toggleButton text-xl text-green-500"
                    onclick="enableElement('input-code-header', 'toggle-input-code-header'); disableElement('input-code-cpp', 'toggle-input-code-cpp');">
                    HEADER
                    </button>
                    <button
                    id="toggle-input-code-cpp"
                    class="toggleButton text-xl"
                    onclick="enableElement('input-code-cpp', 'toggle-input-code-cpp'); disableElement('input-code-header', 'toggle-input-code-header');">
                    C++
                    </button>
                </div>

                <button 
                class="toggleButton absolute top-20 right-10"
                onclick="toggleOverflow('input-code-example-header'); toggleOverflow('input-code-example-cpp');">
                ⇅
                </button>
                

                <div id="input-code-header" class="">
                    <pre id="input-code-example-header" class="code-example-preview h-80">
                        <code class="language-csharp">
#pragma once

#include "Input.h"
#include "Game.h"

class InputManager
{
public:

	InputManager(const InputManager&) = delete;
	InputManager& operator=(const InputManager&) = delete;

	static InputManager& Instance()
	{
		static InputManager instance;
		return instance;
	}

	void HandleEvents(SDL_Event& event);

	bool KeyDown(Key key);
	bool KeyPressed(Key key);
	bool KeyUp(Key key);

	bool MouseButtonDown(MouseButton button);
	bool MouseButtonPressed(MouseButton button);
	bool MouseButtonUp(MouseButton button);

	int MouseX() const;
	int MouseY() const;

private:

	InputManager() { }

	struct InputState
	{
		bool down = false;
		unsigned int updateFrame = 0;

		void SetInput(bool newDown)
		{
			down = newDown;
			updateFrame = GetFrameCount();
		}
	};

	InputState keyStates[(int)Key::Count];
	InputState mouseStates[(int)MouseButton::Count];
	int mouseX = 0;
	int mouseY = 0;
};
                        </code>
                    </pre>
                </div>

                <div id="input-code-cpp" class="hidden">
                    <pre id="input-code-example-cpp" class="code-example-preview h-80">
                        <code class="language-csharp">
#include "InputManager.h"
#include "SDL.h"
#include "glm.hpp"

void InputManager::HandleEvents(SDL_Event& event)
{

	switch (event.type)
	{
        case SDL_KEYDOWN:
        {
            if (event.key.repeat)
                break;

            InputState& state = keyStates[event.key.keysym.scancode];
            state.SetInput(true);
            break;
        }

        case SDL_KEYUP:
        {
            InputState& state = keyStates[event.key.keysym.scancode];
            state.SetInput(false);
            break;
        }

        case SDL_MOUSEBUTTONDOWN:
        {
            InputState& state = mouseStates[event.button.button];
            state.SetInput(true);
            break;
        }

        case SDL_MOUSEBUTTONUP:
        {
            InputState& state = mouseStates[event.button.button];
            state.SetInput(false);
            break;
        }


        case SDL_MOUSEMOTION:
        {
            mouseX = event.motion.x;
            mouseY = event.motion.y;
            break;
        }

	}
}

// key inputs
bool InputManager::KeyDown(Key key)
{
	InputState& state = keyStates[(int)key];
	return state.down;
}

bool InputManager::KeyPressed(Key key)
{
	InputState& state = keyStates[(int)key];
	return state.down && state.updateFrame == GetFrameCount();
}

bool InputManager::KeyUp(Key key)
{
	InputState& state = keyStates[(int)key];
	return !state.down && state.updateFrame == GetFrameCount();
}

// mount inputs
bool InputManager::MouseButtonDown(MouseButton button)
{
	InputState& state = mouseStates[(int)button];
	return state.down;
}

bool InputManager::MouseButtonPressed(MouseButton button)
{
	InputState& state = mouseStates[(int)button];
	return state.down && state.updateFrame == GetFrameCount();
}

bool InputManager::MouseButtonUp(MouseButton button)
{
	InputState& state = mouseStates[(int)button];
	return !state.down && state.updateFrame == GetFrameCount();
}

// mouse movement
int InputManager::MouseX() const
{
	return mouseX;
}

int InputManager::MouseY() const
{
	return mouseY;
}



                        </code>
                    </pre>
                </div>

            </aside>
        </div>

        <!-- DIVIDER -->
        <div class="divider"></div>

        <div class="code-container">
            <!-- TEXTURE MANAGER CODE -->
            <section class="code-example-section">
                
                <div class="flex justify-evenly">
                    <button
                    id="toggle-texture-code-header"
                    class="toggleButton text-xl text-green-500"
                    onclick="enableElement('texture-code-header', 'toggle-texture-code-header'); disableElement('texture-code-cpp', 'toggle-texture-code-cpp');">
                    HEADER
                    </button>
                    <button
                    id="toggle-texture-code-cpp"
                    class="toggleButton text-xl"
                    onclick="enableElement('texture-code-cpp', 'toggle-texture-code-cpp'); disableElement('texture-code-header', 'toggle-texture-code-header');">
                    C++
                    </button>
                </div>

                <button 
                class="toggleButton absolute top-20 right-10"
                onclick="toggleOverflow('texture-code-example-header'); toggleOverflow('texture-code-example-cpp');">
                ⇅
                </button>
                

                <div id="texture-code-header" class="">
                    <pre id="texture-code-example-header" class="code-example-preview h-80">
                        <code class="language-csharp">
#pragma once

#include "SDL.h"
#include "SDL_image.h"
#include "string"
#include "unordered_map"

class TextureManager
{
public:

	TextureManager(const TextureManager&) = delete;
	TextureManager& operator=(const TextureManager&) = delete;

	static TextureManager& Instance()
	{
		static TextureManager instance;
		return instance;
	}

	//SDL_Texture* LoadTexture(const char* textureName, SDL_Renderer* renderer);

	bool Load(const std::string& id, const std::string fileName, SDL_Renderer* renderer);
	void Render(const std::string& id, int x, int y, int width, int height, SDL_Renderer* renderer);
	void Clean();

private:

	TextureManager() { }

	std::unordered_map&lt;std::string, SDL_Texture*&gt; textureMap;
};

                        </code>
                    </pre>
                </div>

                <div id="texture-code-cpp" class="hidden">
                    <pre id="game-code-example-cpp" class="code-example-preview h-80">
                        <code class="language-csharp">
#include "TextureManager.h"
#include "iostream"

bool TextureManager::Load(const std::string& id, const std::string fileName, SDL_Renderer* renderer)
{
	SDL_Surface* tempSurface = IMG_Load(fileName.c_str());
	if (!tempSurface)
	{
		std::cerr &lt;&lt; "Failed to Load Texture! File: " &lt;&lt; fileName &lt;&lt; "Error: " &lt;&lt; IMG_GetError() &lt;&lt; std::endl;
		return false;
	}

	SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, tempSurface);
	SDL_FreeSurface(tempSurface);

	if (!texture)
	{
		std::cerr &lt;&lt; "Failed to Create Texture! File: " &lt;&lt; fileName &lt;&lt; "Error: " &lt;&lt; IMG_GetError() &lt;&lt; std::endl;
		return false;
	}

	textureMap[id] = texture;
	return true;
}

void TextureManager::Render(const std::string& id, int x, int y, int width, int height, SDL_Renderer* renderer)
{
	SDL_Rect srcRect = { 0, 0, width, height };
	SDL_Rect destRect = { x, y, width, height };

	SDL_RenderCopy(renderer, textureMap[id], &srcRect, &destRect);
}

void TextureManager::Clean()
{
	for (auto& texturePair : textureMap)
	{
		SDL_DestroyTexture(texturePair.second);
	}
	textureMap.clear();
}

                        </code>
                    </pre>
                </div>

            </section>

            <!-- TEXTURE MANAGER CODE TEXT -->
            <aside id="texture-code-text" class="code-text-section">
                <h2 class="code-text-heading mt-0 md:mt-8">TEXTURE MANAGER</h2>
                <p class="leading-8">
                    The Texture Manager handles:
                    <p>
                        <span class="font-bold">Loading -</span>
                        <span class="italic">Textures are loaded from files and stored in a map.</span>
                        <br>
                        <span class="font-bold">Rendering -</span>
                        <span class="italic">Draws textures at specified positions and sizes.</span>
                        <br>
                        <span class="font-bold">Cleanup -</span>
                        <span class="italic">Free allocated memory to prevent leaks when quitting game.</span>
                    </p>
                </p>
            </aside>    
        </div>
        
        <!-- DIVIDER -->
        <div class="divider"></div>

        <div class="code-container">
            <!-- COLLISION CODE TEXT -->
            <section id="collision-code-text" class="code-text-section">
                <h2 class="code-text-heading mt-0 md:mt-8">COLLISION</h2>
                <p class="leading-8">
                    The AABB <span class="italic">(Axis-Aligned Bounding Box)</span> struct represent a 2D rectangle used for collision detection.
                    <br>
                    <span class="font-bold">FromPositionSize()</span> 
                    converts a given position and size into an AABB by calculating the
                    <span class="italic">min</span>
                    and
                    <span class="italic">max</span>
                    corners.
                    <br>
                    <span class="font-bold">aabbOverlap()</span>
                    compare two AABB and return whether they are overlapping or not.
                </p>
            </section>

            <!-- COLLISION CODE -->
            <aside class="code-example-section">
                
                <div class="flex justify-evenly">
                    <button
                    id="toggle-collision-code-header"
                    class="toggleButton text-xl text-green-500"
                    onclick="enableElement('collision-code-header', 'toggle-collision-code-header'); disableElement('collision-code-cpp', 'toggle-collision-code-cpp');">
                    HEADER
                    </button>
                    <button
                    id="toggle-collision-code-cpp"
                    class="toggleButton text-xl"
                    onclick="enableElement('collision-code-cpp', 'toggle-collision-code-cpp'); disableElement('collision-code-header', 'toggle-collision-code-header');">
                    C++
                    </button>
                </div>

                <button 
                class="toggleButton absolute top-20 right-10"
                onclick="toggleOverflow('collision-code-example-header'); toggleOverflow('collision-code-example-cpp');">
                ⇅
                </button>
                

                <div id="collision-code-header" class="">
                    <pre id="collision-code-example-header" class="code-example-preview h-80">
                        <code class="language-csharp">
#pragma once

#include "glm.hpp"

struct AABB
{
	static AABB FromPositionSize(glm::vec2 position, glm::vec2 size);

	AABB() { }
	AABB(glm::vec2 in_min, glm::vec2 in_max) : min(in_min), max(in_max) { }

	glm::vec2 min;
	glm::vec2 max;
};

bool aabbOverlap(AABB a, AABB b);

                        </code>
                    </pre>
                </div>

                <div id="collision-code-cpp" class="hidden">
                    <pre id="collision-code-example-cpp" class="code-example-preview h-80">
                        <code class="language-csharp">
#include "AABB.h"

AABB AABB::FromPositionSize(glm::vec2 position, glm::vec2 size)
{
    return AABB(
        position - size * 0.5f,
        position + size * 0.5f
    );
}

bool aabbOverlap(AABB a, AABB b)
{
    return 
        a.max.x >= b.min.x && 
        b.max.x >= a.min.x &&
        a.max.y >= b.min.y && 
        b.max.y >= a.min.y;
}

                        </code>
                    </pre>
                </div>

            </aside>
        </div>

        <!-- DIVIDER -->
        <div class="divider"></div>

        <div class="code-container">
            <!-- CAMERA CODE -->
            <section class="code-example-section">
                
                <div class="flex justify-evenly">
                    <button
                    id="toggle-camera-code-header"
                    class="toggleButton text-xl text-green-500"
                    onclick="enableElement('camera-code-header', 'toggle-camera-code-header'); disableElement('camera-code-cpp', 'toggle-camera-code-cpp');">
                    HEADER
                    </button>
                    <button
                    id="toggle-camera-code-cpp"
                    class="toggleButton text-xl"
                    onclick="enableElement('camera-code-cpp', 'toggle-camera-code-cpp'); disableElement('camera-code-header', 'toggle-camera-code-header');">
                    C++
                    </button>
                </div>

                <button 
                class="toggleButton absolute top-20 right-10"
                onclick="toggleOverflow('camera-code-example-header'); toggleOverflow('camera-code-example-cpp');">
                ⇅
                </button>
                

                <div id="camera-code-header" class="">
                    <pre id="camera-code-example-header" class="code-example-preview h-80">
                        <code class="language-csharp">
#pragma once

#include "glm.hpp"

class Camera
{
public:
	void Update();

	glm::vec2 WorldToScreen(glm::vec2 vector);
	glm::vec2 ScreenToWorld(glm::vec2 vector);

	glm::vec2 position;
	
};

                        </code>
                    </pre>
                </div>

                <div id="camera-code-cpp" class="hidden">
                    <pre id="camera-code-example-cpp" class="code-example-preview h-80">
                        <code class="language-csharp">
#include "Camera.h"
#include "Config.h"
#include "Game.h"
#include "Actor.h"
#include "InputManager.h"

void Camera::Update()
{
	if (Game::Instance().GetPlayer() != nullptr)
	{
		glm::vec2 playerPosition = Game::Instance().GetPlayer()->position;

		position = playerPosition;
	}
}

glm::vec2 Camera::WorldToScreen(glm::vec2 vector)
{
	using namespace Config;
	return vector - position + glm::vec2(WINDOWWIDTH * 0.5f, WINDOWHEIGHT * 0.5f);
}

glm::vec2 Camera::ScreenToWorld(glm::vec2 vector)
{
	using namespace Config;
	return vector + position - glm::vec2(WINDOWWIDTH * 0.5f, WINDOWHEIGHT * 0.5f);
}

                        </code>
                    </pre>
                </div>

            </section>

            <!-- CAMERA CODE TEXT -->
            <aside id="camera-code-text" class="code-text-section">
                <h2 class="code-text-heading mt-0 md:mt-8">CAMERA</h2>
                <p class="leading-8">
                    The Camera class handles:
                    <p>
                        <span class="font-bold">Camera position -</span>
                        <span class="italic">Set to follow the player's position.</span>
                        <br>
                        <span class="font-bold">WorldToScreen -</span>
                        <span class="italic">Converts world coordinates to screen coordinates.</span>
                        <br>
                        <span class="font-bold">ScreenToWorld -</span>
                        <span class="italic">Converts screen coordinates to world coordinates.</span>
                    </p>
                    <br>
                    Converting between world and screen is required to display and interact with objects properly.
                </p>
            </aside>    
        </div>

        <!-- DIVIDER -->
        <div class="divider"></div>

        <div class="code-container">
            <!-- PLAYER CODE TEXT -->
            <section id="player-code-text" class="code-text-section">
                <h2 class="code-text-heading mt-0 md:mt-8">PLAYER CLASS</h2>
                <p class="leading-8">
                    The Player class inherits from the
                    <span class="font-bold">Actor class.</span>
                    It handles:
                    <p>
                        <span class="font-bold">Player Movement -</span>
                        <span class="italic">Horizontal movement, jumping, and gravity.</span>
                        <br>
                        <span class="font-bold">Resolving Collision -</span>
                        <span class="italic">Player position is adjusted based on the smallest overlap.</span>
                        <br>
                        <span class="font-bold">Interact -</span>
                        <span class="italic">Use mouse inputs to place or break blocks.</span>
                        <br>
                    </p>
                </p>
            </section>

            <!-- PLAYER CODE -->
            <aside class="code-example-section">
                
                <div class="flex justify-evenly">
                    <button
                    id="toggle-player-code-header"
                    class="toggleButton text-xl text-green-500"
                    onclick="enableElement('player-code-header', 'toggle-player-code-header'); disableElement('player-code-cpp', 'toggle-player-code-cpp');">
                    HEADER
                    </button>
                    <button
                    id="toggle-player-code-cpp"
                    class="toggleButton text-xl"
                    onclick="enableElement('player-code-cpp', 'toggle-player-code-cpp'); disableElement('player-code-header', 'toggle-player-code-header');">
                    C++
                    </button>
                </div>

                <button 
                class="toggleButton absolute top-20 right-10"
                onclick="toggleOverflow('player-code-example-header'); toggleOverflow('player-code-example-cpp');">
                ⇅
                </button>
                

                <div id="player-code-header" class="">
                    <pre id="player-code-example-header" class="code-example-preview h-80">
                        <code class="language-csharp">
#pragma once

#include "Actor.h"

class Player : public Actor
{
public:

	Player(glm::vec2 position);

	void Update() override;
	void Render() override;

	void Hit(int damage) override;

	void HandleMovement();
	void HandleGravity();
	void HandleJump();

	bool IsGrounded(const AABB& actor, const std::vector&lt;AABB&gt;& collidingActors, float extendedAmount) override;

	bool IsColliding(const AABB& a, const AABB& b, glm::vec2& outOverlap) override;
	void ResolveCollision(Actor* actor, const std::vector&lt;AABB&gt;& collidingActors) override;

	void Use(int i);

private:

	glm::vec2 movementDirection = glm::vec2(0);
	

	float movementSpeed = 150.0f;
	float maxMovementSpeeed = 200.0f;

	float jumpStrength = 200.0f;
	float jumpHeight = 1.0f;
	float jumpTime = 0;
	float startJump = 0;
	float jumpDuration = 0.2f;
	

	float gravity = 500.0f;

	bool isGrounded = false;

};
                        </code>
                    </pre>
                </div>

                <div id="player-code-cpp" class="hidden">
                    <pre id="player-code-example-cpp" class="code-example-preview h-80">
                        <code class="language-csharp">
#include "Player.h"
#include "Game.h"
#include "glm.hpp"
#include "InputManager.h"
#include "Camera.h"
#include "WorldGenerator.h"
#include "TextureManager.h"

Player::Player(glm::vec2 position)
	: Actor(position, glm::vec2(24, 40))
{
	collisionType = ECollision_Type::Player;
}

void Player::Update()
{
	std::vector&lt;Actor*&gt; collidingActors = Game::Instance().GetAllCollidingActors(this, ECollision_Type::Block);
	std::vector&lt;AABB&gt; actorsAABB;

	for (Actor* a : collidingActors)
	{
		AABB aabb = AABB::FromPositionSize(a->position, a->size);
		actorsAABB.push_back(aabb);
	}
	ResolveCollision(this, actorsAABB);


	HandleMovement();
	HandleJump();
	HandleGravity();


	if (InputManager::Instance().MouseButtonPressed(MouseButton::Left))
	{
		Use(0);
	}

	if (InputManager::Instance().MouseButtonPressed(MouseButton::Right))
	{
		Use(1);
	}

}

void Player::Render()
{
	Actor::Render();

	TextureManager::Instance().Render("player", renderPosition.x, renderPosition.y, size.x, size.y, Game::Instance().GetRenderer());


	glm::vec2 newPos = glm::vec2(position.x, position.y + (size.y * 0.5f));
	glm::vec2 newSize = glm::vec2(size.x * 0.75, size.y * 0.25f);

	AABB extendedActor = AABB::FromPositionSize(newPos, newSize);

	int width = extendedActor.max.x - extendedActor.min.x;
	int height = extendedActor.max.y - extendedActor.min.y;

	glm::vec2 renderPosition = newPos - glm::vec2(width, height) * 0.5f;
	renderPosition = Game::Instance().GetCamera()->WorldToScreen(renderPosition);

	Game::Instance().RenderRect(renderPosition.x, renderPosition.y, width, height);
}

void Player::Hit(int damage)
{
	// health check

	Destroy();
}

void Player::HandleMovement()
{

	if (InputManager::Instance().KeyDown(Key::D)) // Right
	{
		velocity.x += movementSpeed * Get_DeltaTime();
		velocity.x = glm::clamp(velocity.x, 0.0f, maxMovementSpeeed);
	}
	else if (InputManager::Instance().KeyDown(Key::A)) // Left
	{
		velocity.x -= movementSpeed * Get_DeltaTime();
		velocity.x = glm::clamp(velocity.x, -maxMovementSpeeed, 0.0f);
	}
	else
	{
		velocity.x = 0;
	}
	

	movementDirection.x = velocity.x;

	position += movementDirection * Get_DeltaTime();
}

void Player::HandleGravity()
{
	std::vector&lt;Actor*&gt; collidingActors = Game::Instance().GetAllCollidingActors(this, ECollision_Type::Block);
	std::vector&lt;AABB&gt; actorsAABB;

	AABB player = AABB::FromPositionSize(this->position, this->size);

	for (Actor* a : collidingActors)
	{
		AABB aabb = AABB::FromPositionSize(a->position, a->size);
		actorsAABB.push_back(aabb);
	}

	if (!IsGrounded(player, actorsAABB, 2.0f))
	{
		velocity.y += gravity * Get_DeltaTime();
	}
	else
	{
		velocity.y = 0;
		isGrounded = true;
	}

	movementDirection.y = velocity.y;
}

void Player::HandleJump()
{	
	if (InputManager::Instance().KeyPressed(Key::Space) && isGrounded)
	{
		velocity.y -= jumpStrength;
	}

	movementDirection.y = velocity.y;
}

bool Player::IsGrounded(const AABB& actor, const std::vector&lt;AABB&gt;& collidingActors, float extendedAmount)
{
	glm::vec2 newPos = glm::vec2(position.x, position.y + (size.y * 0.5f));
	glm::vec2 newSize = glm::vec2(size.x * 0.75, (size.y * 0.25f));

	AABB extendedActor = AABB::FromPositionSize(newPos, newSize);

	for (const auto& a : collidingActors)
	{
		if (aabbOverlap(extendedActor, a))
		{
			isGrounded = true;
			return true;
		}
	}

	isGrounded = false;
	return false;
}

bool Player::IsColliding(const AABB& a, const AABB& b, glm::vec2& outOverlap)
{
	float overlapX = glm::min(a.max.x - b.min.x, b.max.x - a.min.x);
	float overlapY = glm::min(a.max.y - b.min.y, b.max.y - a.min.y);

	if (overlapX > 0 && overlapY > 0)
	{
		outOverlap = glm::vec2(overlapX, overlapY);
		return true;
	}
	return false;
}

void Player::ResolveCollision(Actor* actor, const std::vector&lt;AABB&gt;& collidingActors)
{
	glm::vec2 overlap;

	AABB a = AABB::FromPositionSize(actor->position, actor->size);

	for (const auto& cA : collidingActors)
	{
		if (!IsColliding(a, cA, overlap))
		{
			continue;
		}

		float overlapArea = 0.0f;

		float overlapX = glm::max(0.0f, glm::min(a.max.x, cA.max.x) - glm::max(a.min.x, cA.min.x));
		float overlapY = glm::max(0.0f, glm::min(a.max.y, cA.max.y) - glm::max(a.min.y, cA.min.y));
		overlapArea = overlapX * overlapY;

		if (overlapArea > ((actor->size.x * actor->size.y) * 0.25f))
		{
			actor->velocity = glm::vec2(0);
			return;
		}


		if (overlap.x &lt; overlap.y) // checks smallest axis overlap - x or y?
		{
			if (actor->position.x &lt; cA.min.x)
			{
				actor->position.x -= overlap.x; // adjust position left
			}
			else
			{
				actor->position.x += overlap.x; // adjust position right
			}
			actor->velocity.x = 0;
		}
		else
		{
			if (actor->position.y &lt; cA.min.y)
			{
				actor->position.y -= overlap.y; // adjust position down
			}
			else
			{
				actor->position.y += overlap.y; // adjust position up
			}
			actor->velocity.y = 0;
		}
	}
}


void Player::Use(int i)
{
	int mousePosX = InputManager::Instance().MouseX();
	int mousePosY = InputManager::Instance().MouseY();

	glm::vec2 worldMousePos = Game::Instance().GetCamera()->ScreenToWorld(glm::vec2(mousePosX, mousePosY));

	glm::vec2 blockSize(16);

	glm::vec2 gridPos = glm::floor(worldMousePos / blockSize);

	std::cout &lt;&lt; "Mouse is over grid cell: " &lt;&lt; (int)gridPos.x &lt;&lt; ", " &lt;&lt; (int)gridPos.y &lt;&lt; std::endl;

	int gridWidth = Game::Instance().GetWorldGenerator()->WORLD_WIDTH;
	int gridHeight = Game::Instance().GetWorldGenerator()->WORLD_HEIGHT;

	if (gridPos.x >= 0 && gridPos.x &lt;= gridWidth && gridPos.y >= 0 && gridPos.y &lt;= gridHeight)
	{
		if (i == 0) // break
		{
			Game::Instance().GetWorldGenerator()->DestoryBlockAtPos((int)gridPos.x, (int)gridPos.y);
		}
		else if (i == 1) //place
		{
			Game::Instance().GetWorldGenerator()->CreateBlockAtPos((int)gridPos.x, (int)gridPos.y);
		}
	}
}

                        </code>
                    </pre>
                </div>

            </aside>
        </div>

        <!-- DIVIDER -->
        <div class="divider"></div>

        <div class="code-container">
            <!-- BLOCK CODE -->
            <section class="code-example-section">
                
                <div class="flex justify-evenly">
                    <button
                    id="toggle-block-code-header"
                    class="toggleButton text-xl text-green-500"
                    onclick="enableElement('block-code-header', 'toggle-block-code-header'); disableElement('block-code-cpp', 'toggle-block-code-cpp');">
                    HEADER
                    </button>
                    <button
                    id="toggle-block-code-cpp"
                    class="toggleButton text-xl"
                    onclick="enableElement('block-code-cpp', 'toggle-block-code-cpp'); disableElement('block-code-header', 'toggle-block-code-header');">
                    C++
                    </button>
                </div>

                <button 
                class="toggleButton absolute top-20 right-10"
                onclick="toggleOverflow('block-code-example-header'); toggleOverflow('block-code-example-cpp');">
                ⇅
                </button>
                

                <div id="block-code-header" class="">
                    <pre id="block-code-example-header" class="code-example-preview h-80">
                        <code class="language-csharp">
#pragma once

#include "Actor.h"

class Block : public Actor
{
public:

	Block(glm::vec2 position);

	void Update() override;
	void Render() override;

	void Hit(int damage) override;

};
                        </code>
                    </pre>
                </div>

                <div id="block-code-cpp" class="hidden">
                    <pre id="block-code-example-cpp" class="code-example-preview h-80">
                        <code class="language-csharp">
#include "Block.h"
#include "Game.h"
#include "Player.h"
#include "TextureManager.h"

Block::Block(glm::vec2 position) 
	: Actor(position, glm::vec2(16))
{
	collisionType = ECollision_Type::Block;
}

void Block::Update()
{
	
}

void Block::Render()
{
	Actor::Render();

	TextureManager::Instance().Render("block_dirt", renderPosition.x, renderPosition.y, size.x, size.y, Game::Instance().GetRenderer());

}

void Block::Hit(int damage)
{
	// health check

	Destroy();
}
                        </code>
                    </pre>
                </div>

            </section>

            <!-- BLOCK CODE TEXT -->
            <aside id="block-code-text" class="code-text-section">
                <h2 class="code-text-heading mt-0 md:mt-8">BLOCK CLASS</h2>
                <p class="leading-8">
                    The Block class inherits from the
                    <span class="font-bold">Actor class.</span>
                    <br>
                    The class currently has no any unique logic to it
                    <br>
                    The plan is to add:
                    <p>
                        <span class="font-bold">Behavior -</span>
                        <span class="italic">How the block should interact with the world and other actors.</span>
                        <br>
                        <span class="font-bold">Durability -</span>
                        <span class="italic">Duration it takes to break the block, based on the tool and block behavior.</span>
                        <br>
                    </p>
                </p>
            </aside>    
        </div>

    </main>

    <script>
        function scrollToElement(id) {
            const element = document.getElementById(id);
            if (element) {
                element.scrollIntoView({ behavior: "smooth", block: "center" });
            }
        }
    </script>

    <script>
        function toggleOverflow(id) {
            const preElement = document.getElementById(id);
            let height = "h-80";
            let fullHeight = "h-fit";

            if (preElement.classList.contains(height)) {
                preElement.classList.remove(height);
                preElement.classList.add(fullHeight);
            } else {
                preElement.classList.remove(fullHeight);
                preElement.classList.add(height);
            }
        }
    </script>

    <script>

        function enableElement(codeID, buttonID) {
            
            const code = document.getElementById(codeID);
            const button = document.getElementById(buttonID);

            let greenText = "text-green-500";

            if (code.classList.contains("hidden")) {
                code.classList.remove("hidden");
            }

            if (!button.classList.contains(greenText)) {
                button.classList.add(greenText);
            }

        }

        function disableElement(codeID, buttonID) {
            
            const code = document.getElementById(codeID);
            const button = document.getElementById(buttonID);

            let greenText = "text-green-500";

            if (!code.classList.contains("hidden")) {
                code.classList.add("hidden");
            }

            if (button.classList.contains(greenText)) {
                button.classList.remove(greenText);
            }

        }

    </script>

</body>
</html>
