<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rasmus Göransson - Primitive Engine</title>
    <link rel="stylesheet" href="output.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;400;600;700&display=swap">

    <link rel="stylesheet" href="../ScriptStyle/prism-vsc-dark-plus.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-csharp.min.js"></script>
</head>

<body class="bg-teal-900 text-white font-exo2">
    
    <!-- Header -->
    <header class="header-section">
        <!-- Left Section -->
        <div class="header-left">
            <h1 class="header-title">RASMUS GÖRANSSON</h1>
            <div class="personal-info mt-4 md:mt-2 flex justify-between items-start">
                <h2 class="header-subtitle">GAME PROGRAMMER</h2>
                <div class="social-links flex space-x-4">
                    <a href="https://www.linkedin.com/in/rasmus-g/" target="_blank">
                        <img src="../Images/linkedin_icon.png" alt="LinkedIn" class="social-link-icon">
                    </a>
                    <a href="https://github.com/Hocz" target="_blank">
                        <img src="../Images/github_icon.png" alt="GitHub" class="social-link-icon">
                    </a>
                    <a href="../Documents/Rasmus_Göransson_CV(ENG).pdf" target="_blank">
                        <img src="../Images/cv_icon.png" alt="CV" class="social-link-icon">
                    </a>
                </div>
            </div>
        </div>

        <!-- Right Section -->
        <div class="header-right mt-4 md:mt-0 flex flex-col items-center">
            <nav>
                <ul class="flex space-x-4 text-center py-0 pr-8">
                    <li><a href="index.html" class="nav-link rounded-xl border-2 border-green-500">HOME</a></li>
                    <li><a href="about.html" class="nav-link rounded-xl border-2 border-green-500">ABOUT ME</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="container mx-auto px-4 py-8 text-white">
        <!-- Content Area -->
        <div id="top" class="flex flex-col md:flex-row md:space-x-8">
            <!-- Main Content -->
            <section class="md:w-2/3 bg-neutral-900 bg-opacity-80 p-6 shadow-md rounded-3xl">
                <h2 class="text-3xl font-semibold mb-4 text-green-500">Primitive Engine</h2>
                <p class="leading-8 text-xl py-4">
                    Primitive Engine is a project I started to improve my C++ skills. 
                    Aside from C++ I am also using SDL2 for window management and rendering as well as GLM for math, that way I can focus more on gameplay features and less on the underlaying math.
                </p>
                <p class="leading-8 text-xl py-4">
                    This project is still a work in progress, and I have many more features planned. 
                    I'm focusing on implementing a solid foundation without making it too generalized, while also refining important aspects like collision resolution and player movement to create a more enjoyable experience. 
                </p>
                <p class="leading-8 text-xl py-4">
                    My goal is to continually evolve the game and add new features as I progress.
                </p>
            </section>

            <!-- Sidebar -->
            <aside class="md:w-1/3 bg-neutral-900 bg-opacity-80 p-6 shadow-md my-8 md:my-0 rounded-3xl">
                <h2 class="text-3xl font-semibold mb-4 text-center text-green-500">Ideas</h2>
                <div>
                    <p class="leading-8 text-xl py-4">
                        My plan for this project is to create a game similar to Terraria, a 2D block-based game focused on building, mining and combat.
                    </p>
                    <p class="leading-8 text-xl py-4">
                        Additionally, I aim to explore procedural world generation, creating random terrain along with biomes, caves and other natural features like trees and ore veins.
                    </p>
            </aside>
        </div>

        <!-- Code Snippets Buttons-->
        <div class="sticky top-4 z-50 flex flex-wrap md:flex-row md:space-x-8 justify-center gap-2 bg-neutral-900 bg-opacity-80 rounded-3xl p-4 my-8">
            <button class="code-snippet-button" onclick="scrollToElement('top')">↑</button>
            <button class="code-snippet-button" onclick="scrollToElement('code1example')">Game Class</button>
            <button class="code-snippet-button" onclick="scrollToElement('code2example')">Input Manager</button>
            <button class="code-snippet-button" onclick="scrollToElement('code3example')">Texture Manager</button>
            <button class="code-snippet-button" onclick="scrollToElement('code4example')">Collision</button>
            <button class="code-snippet-button" onclick="scrollToElement('code5example')">Camera</button>
            <button class="code-snippet-button" onclick="scrollToElement('code6example')">Player Class</button>
            <button class="code-snippet-button" onclick="scrollToElement('code7example')">Block Class</button>

        </div>

        <!-- Code Example 1 -->
        <div class="code-info flex flex-col md:flex-row md:space-x-8 mt-8 relative">    
            <section class="md:w-2/3 bg-neutral-900 bg-opacity-80 p-6 rounded-3xl relative">
                
                <button 
                class="toggleButton absolute top-10 right-10"
                onclick="toggleOverflow('code1pre-h', 'code1pre-cpp')">
                ⇅
                </button>
                <button
                id="toggle-button1"
                class="toggleButton absolute top-10 right-20"
                onclick="toggleSections('code1-header', 'code1-cpp', 'toggle-button1')">
                header
                </button>

                <div id="code1-header" class="">
                    <pre id="code1pre-h" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#pragma once

#include "iostream"
#include "SDL_image.h"
#include "SDL.h"
#include "vector"

#define NOMINMAX
#include "windows.h"

static constexpr int max_Actors = 50;

// Forward declarations
class Actor;
enum class ECollision_Type;
class Camera;
class WorldGenerator;

class Game {

public:

	Game(const Game&) = delete;
	Game& operator=(const Game&) = delete;

	static Game& Instance()
	{
		static Game instance;
		return instance;
	}


	void Init(const char* title, int xPos, int yPos, int width, int height, bool fullscreen);

	void HandleEvents();

	void Update();

	void Render();


	void Clean();

	bool Running() { return isRunning; }

	void SetRenderColor();
	void FillRenderRect(int x, int y, int width, int height);
	void RenderRect(int x, int y, int width, int height);

	Actor* GetCollidingActor(Actor* other, ECollision_Type collisionType);
	std::vector&lt;Actor*&gt; GetAllCollidingActors(Actor* other, ECollision_Type collisionType);

	SDL_Renderer* GetRenderer();

	// getter functions
	Actor* GetPlayer();
	Camera* GetCamera();
	WorldGenerator* GetWorldGenerator();

private:

	Game();
	~Game();

	SDL_Window* window;
	SDL_Renderer* renderer;

	bool isRunning;

	static constexpr float BACKGROUND_GRID_SIZE = 50.f;

	Actor* actors[max_Actors] = { nullptr };


	WorldGenerator* worldGenerator = nullptr;


	Actor* player = nullptr;

	Camera* camera = nullptr;

};


// game time
float Get_DeltaTime();

float Get_CurrentTime();

float Get_TimePassedSince(float time);

int GetFrameCount();


                        </code>
                    </pre>
                </div>

                <div id="code1-cpp" class="hidden">
                    <pre id="code1pre-cpp" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#include "Game.h"
#include "Player.h"
#include "Camera.h"
#include "glm.hpp"
#include "InputManager.h"
#include "WorldGenerator.h"
#include "AABB.h"
#include "TextureManager.h"

static float deltaTime = 0.f;
static unsigned int frameCount = 0;


// time
static LARGE_INTEGER clockFrequency;
static LARGE_INTEGER lastFrameTime;
static LARGE_INTEGER startupTime;

Game::Game()
{
    worldGenerator = new WorldGenerator();
    
    actors[0] = new Player(glm::vec2(32, -32));
    player = actors[0];


    camera = new Camera();
}

Game::~Game() // DELETE POINTERS
{
    delete player;

    delete camera;
}

void Game::Init(const char* title, int xPos, int yPos, int width, int height, bool fullscreen)
{
    int flags = 0;
    if (fullscreen)
    {
        flags = SDL_WINDOW_FULLSCREEN;
    }

    if (SDL_Init(SDL_INIT_EVERYTHING) == 0)
    {
        // initialize window
        window = SDL_CreateWindow(title, xPos, yPos, width, height, flags);
        if (window)
        {
            std::cout &lt;&lt; "Window created!" &lt;&lt; std::endl;
        }


        // initialize renderer
        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
        if (renderer)
        {
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
            std::cout &lt;&lt; "Renderer Created!" &lt;&lt; std::endl;
        }


        // initialize clock for delta time calc
        QueryPerformanceFrequency(&clockFrequency);
        QueryPerformanceCounter(&startupTime);
        lastFrameTime = startupTime;

        isRunning = true;
    }
    else
    {
        isRunning = false;
    }

    TextureManager::Instance().Load("player", "Textures/player.png", renderer);
    TextureManager::Instance().Load("block_dirt", "Textures/block_dirt.png", renderer);
}

void Game::HandleEvents()
{
    SDL_Event event;
    SDL_PollEvent(&event);
    
    switch (event.type)
    {
        case SDL_QUIT:
        {
            isRunning = false;
            break;
        }
    }
    
    InputManager::Instance().HandleEvents(event);
}

void Game::Update()
{
    LARGE_INTEGER currentFrameTime;
    QueryPerformanceCounter(&currentFrameTime);
    deltaTime = float(currentFrameTime.QuadPart - lastFrameTime.QuadPart) / clockFrequency.QuadPart;

    lastFrameTime = currentFrameTime;

    if (player != nullptr)
    {
        player->Update();
    }

    for (int x = 0; x &lt; worldGenerator->WORLD_WIDTH; x++)
    {
        for (int y = 0; y &lt; worldGenerator->WORLD_HEIGHT; y++)
        {
            Block* block = worldGenerator->worldGrid[x][y];

            if (block != nullptr)
            {
                block->Update();
            }
        }
    }


    camera->Update();

    // last thing in update
    frameCount++;
}

void Game::Render()
{
    // clear screen
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // background grid
    for (int x = -50; x &lt;= 50; x++)
    {
        for (int y = -50; y &lt;= 50; y++)
        {
            if ((x + y) % 2 == 0)
            {
                SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);
            }
            else
            {
                SDL_SetRenderDrawColor(renderer, 150, 150, 150, 255);
            }

            glm::vec2 position = glm::vec2(x * BACKGROUND_GRID_SIZE, y * BACKGROUND_GRID_SIZE);
            position = camera->WorldToScreen(position);

            SDL_Rect rect = { position.x, position.y, BACKGROUND_GRID_SIZE, BACKGROUND_GRID_SIZE };
            SDL_RenderFillRect(renderer, &rect);
        }
    }

    if (worldGenerator->worldGrid != nullptr)
    {
        for (int x = 0; x &lt; worldGenerator->WORLD_WIDTH; x++)
        {
            for (int y = 0; y &lt; worldGenerator->WORLD_HEIGHT; y++)
            {
                if (worldGenerator->worldGrid[x][y] != nullptr)
                {
                    worldGenerator->worldGrid[x][y]->Render();
                }
            }
        }
    }

    if (player != nullptr)
    {
        player->Render();
    }

    SDL_RenderPresent(renderer);
}

void Game::Clean()
{
    TextureManager::Instance().Clean();

    SDL_DestroyWindow(window);
    SDL_DestroyRenderer(renderer);
    SDL_Quit();
    std::cout &lt;&lt; "Game Cleaned" &lt;&lt; std::endl;
}


void Game::SetRenderColor()
{
    // white color
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
}

void Game::FillRenderRect(int x, int y, int width, int height)
{
    SDL_Rect rect = { x, y, width, height };
    SDL_RenderFillRect(renderer, &rect);
}

void Game::RenderRect(int x, int y, int width, int height)
{
    SDL_SetRenderDrawColor(renderer, 10, 10, 10, 255);
    SDL_Rect rect = { x, y, width, height };
    SDL_RenderDrawRect(renderer, &rect);
}

Actor* Game::GetCollidingActor(Actor* actor, ECollision_Type collisionType)
{
    for (int i = 0; i &lt; max_Actors; i++)
    {
        if (actors[i] == actor)
            continue;

        if (actors[i] == nullptr)
            continue;

        if (actors[i]->collisionType != collisionType)
            continue;

        AABB a = AABB::FromPositionSize(actor->position, actor->size);
        AABB b = AABB::FromPositionSize(actors[i]->position, actors[i]->size);

        if (aabbOverlap(a, b))
        {
            return actors[i];
        }
    }
    
    return nullptr;
}

std::vector&lt;Actor*&gt; Game::GetAllCollidingActors(Actor* actor, ECollision_Type collisionType)
{
    std::vector&lt;Actor*&gt; collidingActors;
    collidingActors.clear();

    if (worldGenerator->worldGrid != nullptr)
    {
        for (int x = 0; x &lt; worldGenerator->WORLD_WIDTH; x++)
        {
            for (int y = 0; y &lt; worldGenerator->WORLD_HEIGHT; y++)
            {
                Block* block = worldGenerator->worldGrid[x][y];

                if (block == nullptr)
                    continue;

                if (block->collisionType != collisionType)
                    continue;

                AABB a = AABB::FromPositionSize(actor->position, actor->size);
                AABB b = AABB::FromPositionSize(block->position, block->size);

                if (aabbOverlap(a, b))
                {
                    collidingActors.push_back(block);
                }
            }
        }
    }

    return collidingActors;
}

SDL_Renderer* Game::GetRenderer()
{
    return renderer;
}


Actor* Game::GetPlayer()
{
    return player;
}

Camera* Game::GetCamera()
{
    return camera;
}

WorldGenerator* Game::GetWorldGenerator()
{
    return worldGenerator;
}


float Get_DeltaTime()
{
    return deltaTime;
}

float Get_CurrentTime()
{
    return float(lastFrameTime.QuadPart - startupTime.QuadPart) / clockFrequency.QuadPart;
}

float Get_TimePassedSince(float time)
{
    return Get_CurrentTime() - time;
}

int GetFrameCount()
{
    return frameCount;
}
                        </code>
                    </pre>
                </div>

            </section>

            <!-- Sidebar -->
            <aside id="code1example" class="md:w-1/3 bg-neutral-900 bg-opacity-80 rounded-3xl p-6 my-8 md:my-0 h-96 overflow-y-auto">
                <h2 class="text-3xl font-semibold mb-4 text-green-500 shadow-md shadow-black p-2 text-center rounded-2xl">Game Class</h2>
                <p class="leading-8 py-1">
                    The Game class is the core of the engine, managing initialization, the game loop, event handling, time management and cleanup.
                </p>
                <p class="leading-8 py-1">
                    Initialization sets up the game window, renderer and loads textures.
                </p>
                <p class="leading-8 py-1">
                    Event handling processes player input events and quit requests.
                </p>
                <p class="leading-8 py-1">
                    The game loop continuously updates the game state and renders visuals.
                </p>
                <p class="leading-8 py-1">
                    Time management tracks time, framecount and calculates delta time.
                </p>
                <p class="leading-8 py-1">
                    Cleanup properly shuts down the game and prevents memory leaks.
                </p>
            </aside>    
        </div>

        <!-- Code Example 2 -->
        <div class="code-info flex flex-col md:flex-row md:space-x-8 mt-20">
            <section id="code2example" class="md:w-1/3 bg-neutral-900 bg-opacity-80 p-6 rounded-3xl h-fit">
                <h2 class="text-3xl font-semibold mb-4 text-green-500 shadow-md shadow-black p-2 text-center rounded-2xl">Input Manager</h2>
                <p class="leading-8 py-1">
                    The InputManager class handles keyboard and mouse input using SDL events. 
                </p>
                <p class="leading-8 py-1">
                    It tracks key and mouse button states, detecting if its pressed, held or released.
                    It also keeps track of the mouse position.
                </p>
                <p class="leading-8 py-1">
                    All inputs are frame-accurate, ensuring accurate and responsive input handling.
                </p>
            </section>

            <!-- Sidebar -->
            <aside class="md:w-2/3 bg-neutral-900 bg-opacity-80 rounded-3xl p-6 my-8 md:my-0 relative">
                
                <button 
                class="toggleButton absolute top-10 right-10"
                onclick="toggleOverflow('code2pre-h', 'code2pre-cpp')">
                ⇅
                </button>
                <button 
                id="toggle-button2"
                class="toggleButton absolute top-10 right-20"
                onclick="toggleSections('code2-header', 'code2-cpp', 'toggle-button2')">
                header
                </button>

                <div id="code2-header" class="">
                    <pre id="code2pre-h" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#pragma once

#include "Input.h"
#include "Game.h"

class InputManager
{
public:

	InputManager(const InputManager&) = delete;
	InputManager& operator=(const InputManager&) = delete;

	static InputManager& Instance()
	{
		static InputManager instance;
		return instance;
	}

	void HandleEvents(SDL_Event& event);

	bool KeyDown(Key key);
	bool KeyPressed(Key key);
	bool KeyUp(Key key);

	bool MouseButtonDown(MouseButton button);
	bool MouseButtonPressed(MouseButton button);
	bool MouseButtonUp(MouseButton button);

	int MouseX() const;
	int MouseY() const;

private:

	InputManager() { }

	struct InputState
	{
		bool down = false;
		unsigned int updateFrame = 0;

		void SetInput(bool newDown)
		{
			down = newDown;
			updateFrame = GetFrameCount();
		}
	};

	InputState keyStates[(int)Key::Count];
	InputState mouseStates[(int)MouseButton::Count];
	int mouseX = 0;
	int mouseY = 0;
};
                        </code>
                    </pre>
                </div>

                <div id="code2-cpp" class="hidden">
                    <pre id="code2pre-cpp" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#include "InputManager.h"
#include "SDL.h"
#include "glm.hpp"

void InputManager::HandleEvents(SDL_Event& event)
{

	switch (event.type)
	{
        case SDL_KEYDOWN:
        {
            if (event.key.repeat)
                break;

            InputState& state = keyStates[event.key.keysym.scancode];
            state.SetInput(true);
            break;
        }

        case SDL_KEYUP:
        {
            InputState& state = keyStates[event.key.keysym.scancode];
            state.SetInput(false);
            break;
        }

        case SDL_MOUSEBUTTONDOWN:
        {
            InputState& state = mouseStates[event.button.button];
            state.SetInput(true);
            break;
        }

        case SDL_MOUSEBUTTONUP:
        {
            InputState& state = mouseStates[event.button.button];
            state.SetInput(false);
            break;
        }


        case SDL_MOUSEMOTION:
        {
            mouseX = event.motion.x;
            mouseY = event.motion.y;
            break;
        }

	}
}

// key inputs
bool InputManager::KeyDown(Key key)
{
	InputState& state = keyStates[(int)key];
	return state.down;
}

bool InputManager::KeyPressed(Key key)
{
	InputState& state = keyStates[(int)key];
	return state.down && state.updateFrame == GetFrameCount();
}

bool InputManager::KeyUp(Key key)
{
	InputState& state = keyStates[(int)key];
	return !state.down && state.updateFrame == GetFrameCount();
}

// mount inputs
bool InputManager::MouseButtonDown(MouseButton button)
{
	InputState& state = mouseStates[(int)button];
	return state.down;
}

bool InputManager::MouseButtonPressed(MouseButton button)
{
	InputState& state = mouseStates[(int)button];
	return state.down && state.updateFrame == GetFrameCount();
}

bool InputManager::MouseButtonUp(MouseButton button)
{
	InputState& state = mouseStates[(int)button];
	return !state.down && state.updateFrame == GetFrameCount();
}

// mouse movement
int InputManager::MouseX() const
{
	return mouseX;
}

int InputManager::MouseY() const
{
	return mouseY;
}



                        </code>
                    </pre>
                </div>

            </aside>
        </div>

        <!-- Code Example 3 -->
        <div class="code-info flex flex-col md:flex-row md:space-x-8 mt-8 relative">
            <section class="md:w-2/3 bg-neutral-900 bg-opacity-80 p-6 rounded-3xl relative">
                
                <button 
                class="toggleButton absolute top-10 right-10"
                onclick="toggleOverflow('code3pre-h', 'code3pre-cpp')">
                ⇅
                </button>
                <button 
                id="toggle-button3"
                class="toggleButton absolute top-10 right-20"
                onclick="toggleSections('code3-header', 'code3-cpp', 'toggle-button3')">
                header
                </button>

                <div id="code3-header" class="">
                    <pre id="code3pre-h" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#pragma once

#include "SDL.h"
#include "SDL_image.h"
#include "string"
#include "unordered_map"

class TextureManager
{
public:

	TextureManager(const TextureManager&) = delete;
	TextureManager& operator=(const TextureManager&) = delete;

	static TextureManager& Instance()
	{
		static TextureManager instance;
		return instance;
	}

	//SDL_Texture* LoadTexture(const char* textureName, SDL_Renderer* renderer);

	bool Load(const std::string& id, const std::string fileName, SDL_Renderer* renderer);
	void Render(const std::string& id, int x, int y, int width, int height, SDL_Renderer* renderer);
	void Clean();

private:

	TextureManager() { }

	std::unordered_map&lt;std::string, SDL_Texture*&gt; textureMap;
};

                        </code>
                    </pre>
                </div>

                <div id="code3-cpp" class="hidden">
                    <pre id="code3pre-cpp" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#include "TextureManager.h"
#include "iostream"

bool TextureManager::Load(const std::string& id, const std::string fileName, SDL_Renderer* renderer)
{
	SDL_Surface* tempSurface = IMG_Load(fileName.c_str());
	if (!tempSurface)
	{
		std::cerr &lt;&lt; "Failed to Load Texture! File: " &lt;&lt; fileName &lt;&lt; "Error: " &lt;&lt; IMG_GetError() &lt;&lt; std::endl;
		return false;
	}

	SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, tempSurface);
	SDL_FreeSurface(tempSurface);

	if (!texture)
	{
		std::cerr &lt;&lt; "Failed to Create Texture! File: " &lt;&lt; fileName &lt;&lt; "Error: " &lt;&lt; IMG_GetError() &lt;&lt; std::endl;
		return false;
	}

	textureMap[id] = texture;
	return true;
}

void TextureManager::Render(const std::string& id, int x, int y, int width, int height, SDL_Renderer* renderer)
{
	SDL_Rect srcRect = { 0, 0, width, height };
	SDL_Rect destRect = { x, y, width, height };

	SDL_RenderCopy(renderer, textureMap[id], &srcRect, &destRect);
}

void TextureManager::Clean()
{
	for (auto& texturePair : textureMap)
	{
		SDL_DestroyTexture(texturePair.second);
	}
	textureMap.clear();
}

                        </code>
                    </pre>
                </div>

            </section>

            <!-- Sidebar -->
            <aside id="code3example" class="md:w-1/3 bg-neutral-900 bg-opacity-80 rounded-3xl p-6 my-8 md:my-0 h-fit">
                <h2 class="text-3xl font-semibold mb-4 text-green-500 shadow-md shadow-black p-2 text-center rounded-2xl">Texture Manager</h2>
                <p class="leading-8 py-1">
                    The Texture Manager class handles loading, rendering and cleanup of textures.
                </p>
                <p class="leading-8 py-1">
                    Textures are loaded from files and stored in a map.
                </p>
                <p class="leading-8 py-1">
                    Rendering draws textures at specified positions and sizes.
                </p>
                <p class="leading-8 py-1">
                    Cleaning up frees allocated memory to prevent memory leaks when game quits.
                </p>
            </aside>    
        </div>
        

        <!-- Code Example 4 -->
        <div class="code-info flex flex-col md:flex-row md:space-x-8 mt-20">
            <section id="code4example" class="md:w-1/3 bg-neutral-900 bg-opacity-80 p-6 rounded-3xl h-fit">
                <h2 class="text-3xl font-semibold mb-4 text-green-500 shadow-md shadow-black p-2 text-center rounded-2xl">Collision</h2>
                <p class="leading-8 py-1">
                    The AABB (Axis-Aligned Bounding Box) struct represent a 2D rectangle used for collision detection.
                </p>
                <p class="leading-8 py-1">
                    FromPositionSize takes a position and a size and converts it into an AABB by calculating the min and max corners.
                </p>
                <p class="leading-8 py-1">
                    aabbOverlap is an overlap check that compare two AABB and return if they are overlapping or not.
                </p>
            </section>

            <!-- Sidebar -->
            <aside class="md:w-2/3 bg-neutral-900 bg-opacity-80 rounded-3xl p-6 my-8 md:my-0 relative">
                
                <button 
                class="toggleButton absolute top-10 right-10"
                onclick="toggleOverflow('code4pre-h', 'code4pre-cpp')">
                ⇅
                </button>
                <button 
                id="toggle-button4"
                class="toggleButton absolute top-10 right-20"
                onclick="toggleSections('code4-header', 'code4-cpp', 'toggle-button4')">
                header
                </button>

                <div id="code4-header" class="">
                    <pre id="code4pre-h" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#pragma once

#include "glm.hpp"

struct AABB
{
	static AABB FromPositionSize(glm::vec2 position, glm::vec2 size);

	AABB() { }
	AABB(glm::vec2 in_min, glm::vec2 in_max) : min(in_min), max(in_max) { }

	glm::vec2 min;
	glm::vec2 max;
};

bool aabbOverlap(AABB a, AABB b);

                        </code>
                    </pre>
                </div>

                <div id="code4-cpp" class="hidden">
                    <pre id="code4pre-cpp" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#include "AABB.h"

AABB AABB::FromPositionSize(glm::vec2 position, glm::vec2 size)
{
    return AABB(
        position - size * 0.5f,
        position + size * 0.5f
    );
}

bool aabbOverlap(AABB a, AABB b)
{
    return 
        a.max.x >= b.min.x && 
        b.max.x >= a.min.x &&
        a.max.y >= b.min.y && 
        b.max.y >= a.min.y;
}

                        </code>
                    </pre>
                </div>

            </aside>
        </div>

        <!-- Code Example 5 -->
        <div class="code-info flex flex-col md:flex-row md:space-x-8 mt-8 relative">
            <section class="md:w-2/3 bg-neutral-900 bg-opacity-80 p-6 rounded-3xl relative">
                
                <button 
                class="toggleButton absolute top-10 right-10"
                onclick="toggleOverflow('code5pre-h', 'code5pre-cpp')">
                ⇅
                </button>
                <button 
                id="toggle-button5"
                class="toggleButton absolute top-10 right-20"
                onclick="toggleSections('code5-header', 'code5-cpp', 'toggle-button5')">
                header
                </button>

                <div id="code5-header" class="">
                    <pre id="code5pre-h" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#pragma once

#include "glm.hpp"

class Camera
{
public:
	void Update();

	glm::vec2 WorldToScreen(glm::vec2 vector);
	glm::vec2 ScreenToWorld(glm::vec2 vector);

	glm::vec2 position;
	
};

                        </code>
                    </pre>
                </div>

                <div id="code5-cpp" class="hidden">
                    <pre id="code5pre-cpp" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#include "Camera.h"
#include "Config.h"
#include "Game.h"
#include "Actor.h"
#include "InputManager.h"

void Camera::Update()
{
	if (Game::Instance().GetPlayer() != nullptr)
	{
		glm::vec2 playerPosition = Game::Instance().GetPlayer()->position;

		position = playerPosition;
	}
}

glm::vec2 Camera::WorldToScreen(glm::vec2 vector)
{
	using namespace Config;
	return vector - position + glm::vec2(WINDOWWIDTH * 0.5f, WINDOWHEIGHT * 0.5f);
}

glm::vec2 Camera::ScreenToWorld(glm::vec2 vector)
{
	using namespace Config;
	return vector + position - glm::vec2(WINDOWWIDTH * 0.5f, WINDOWHEIGHT * 0.5f);
}

                        </code>
                    </pre>
                </div>

            </section>

            <!-- Sidebar -->
            <aside id="code5example" class="md:w-1/3 bg-neutral-900 bg-opacity-80 rounded-3xl p-6 my-8 md:my-0 h-fit">
                <h2 class="text-3xl font-semibold mb-4 text-green-500 shadow-md shadow-black p-2 text-center rounded-2xl">Camera</h2>
                <p class="leading-8 py-1">
                    The Camera class managees it's position and converts coordinates between world space and screen space, which is essential for interacting with objetcs on screen.
                </p>
                <p class="leading-8 py-1">
                    The camera position is currently set to follow the player's position.
                </p>
                <p class="leading-8 py-1">
                    The WorldToScreen converts world coordinates to screen coordinates based on the camera's position.
                </p>
                <p class="leading-8 py-1">
                    The ScreenToWorld converts screen coordinates to world coordinates.
                </p>
            </aside>    
        </div>

        <!-- Code Example 6 -->
        <div class="code-info flex flex-col md:flex-row md:space-x-8 mt-20">
            <section id="code6example" class="md:w-1/3 bg-neutral-900 bg-opacity-80 p-6 rounded-3xl h-fit">
                <h2 class="text-3xl font-semibold mb-4 text-green-500 shadow-md shadow-black p-2 text-center rounded-2xl">Player Class</h2>
                <p class="leading-8 py-1">
                    The Player class represents the player character and inherits from the Actor class.
                </p>
                <p class="leading-8 py-1">
                    Player movement includes horizontal movement, jumping and gravity. 
                </p>
                <p class="leading-8 py-1">
                    To resolve collisions, the player's position is adjusted based on the smallest overlap with other objects.
                </p>
                <p class="leading-8 py-1">
                    The player can interact with the world using mouse inputs to either place or break blocks. 
                </p>
            </section>

            <!-- Sidebar -->
            <aside class="md:w-2/3 bg-neutral-900 bg-opacity-80 rounded-3xl p-6 my-8 md:my-0 relative">
                
                <button 
                class="toggleButton absolute top-10 right-10"
                onclick="toggleOverflow('code6pre-h', 'code6pre-cpp')">
                ⇅
                </button>
                <button 
                id="toggle-button6"
                class="toggleButton absolute top-10 right-20"
                onclick="toggleSections('code6-header', 'code6-cpp', 'toggle-button6')">
                header
                </button>

                <div id="code6-header" class="">
                    <pre id="code6pre-h" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#pragma once

#include "Actor.h"

class Player : public Actor
{
public:

	Player(glm::vec2 position);

	void Update() override;
	void Render() override;

	void Hit(int damage) override;

	void HandleMovement();
	void HandleGravity();
	void HandleJump();

	bool IsGrounded(const AABB& actor, const std::vector&lt;AABB&gt;& collidingActors, float extendedAmount) override;

	bool IsColliding(const AABB& a, const AABB& b, glm::vec2& outOverlap) override;
	void ResolveCollision(Actor* actor, const std::vector&lt;AABB&gt;& collidingActors) override;

	void Use(int i);

private:

	glm::vec2 movementDirection = glm::vec2(0);
	

	float movementSpeed = 150.0f;
	float maxMovementSpeeed = 200.0f;

	float jumpStrength = 200.0f;
	float jumpHeight = 1.0f;
	float jumpTime = 0;
	float startJump = 0;
	float jumpDuration = 0.2f;
	

	float gravity = 500.0f;

	bool isGrounded = false;

};
                        </code>
                    </pre>
                </div>

                <div id="code6-cpp" class="hidden">
                    <pre id="code6pre-cpp" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#include "Player.h"
#include "Game.h"
#include "glm.hpp"
#include "InputManager.h"
#include "Camera.h"
#include "WorldGenerator.h"
#include "TextureManager.h"

Player::Player(glm::vec2 position)
	: Actor(position, glm::vec2(24, 40))
{
	collisionType = ECollision_Type::Player;
}

void Player::Update()
{
	std::vector&lt;Actor*&gt; collidingActors = Game::Instance().GetAllCollidingActors(this, ECollision_Type::Block);
	std::vector&lt;AABB&gt; actorsAABB;

	for (Actor* a : collidingActors)
	{
		AABB aabb = AABB::FromPositionSize(a->position, a->size);
		actorsAABB.push_back(aabb);
	}
	ResolveCollision(this, actorsAABB);


	HandleMovement();
	HandleJump();
	HandleGravity();


	if (InputManager::Instance().MouseButtonPressed(MouseButton::Left))
	{
		Use(0);
	}

	if (InputManager::Instance().MouseButtonPressed(MouseButton::Right))
	{
		Use(1);
	}

}

void Player::Render()
{
	Actor::Render();

	TextureManager::Instance().Render("player", renderPosition.x, renderPosition.y, size.x, size.y, Game::Instance().GetRenderer());


	glm::vec2 newPos = glm::vec2(position.x, position.y + (size.y * 0.5f));
	glm::vec2 newSize = glm::vec2(size.x * 0.75, size.y * 0.25f);

	AABB extendedActor = AABB::FromPositionSize(newPos, newSize);

	int width = extendedActor.max.x - extendedActor.min.x;
	int height = extendedActor.max.y - extendedActor.min.y;

	glm::vec2 renderPosition = newPos - glm::vec2(width, height) * 0.5f;
	renderPosition = Game::Instance().GetCamera()->WorldToScreen(renderPosition);

	Game::Instance().RenderRect(renderPosition.x, renderPosition.y, width, height);
}

void Player::Hit(int damage)
{
	// health check

	Destroy();
}

void Player::HandleMovement()
{

	if (InputManager::Instance().KeyDown(Key::D)) // Right
	{
		velocity.x += movementSpeed * Get_DeltaTime();
		velocity.x = glm::clamp(velocity.x, 0.0f, maxMovementSpeeed);
	}
	else if (InputManager::Instance().KeyDown(Key::A)) // Left
	{
		velocity.x -= movementSpeed * Get_DeltaTime();
		velocity.x = glm::clamp(velocity.x, -maxMovementSpeeed, 0.0f);
	}
	else
	{
		velocity.x = 0;
	}
	

	movementDirection.x = velocity.x;

	position += movementDirection * Get_DeltaTime();
}

void Player::HandleGravity()
{
	std::vector&lt;Actor*&gt; collidingActors = Game::Instance().GetAllCollidingActors(this, ECollision_Type::Block);
	std::vector&lt;AABB&gt; actorsAABB;

	AABB player = AABB::FromPositionSize(this->position, this->size);

	for (Actor* a : collidingActors)
	{
		AABB aabb = AABB::FromPositionSize(a->position, a->size);
		actorsAABB.push_back(aabb);
	}

	if (!IsGrounded(player, actorsAABB, 2.0f))
	{
		velocity.y += gravity * Get_DeltaTime();
	}
	else
	{
		velocity.y = 0;
		isGrounded = true;
	}

	movementDirection.y = velocity.y;
}

void Player::HandleJump()
{	
	if (InputManager::Instance().KeyPressed(Key::Space) && isGrounded)
	{
		velocity.y -= jumpStrength;
	}

	movementDirection.y = velocity.y;
}

bool Player::IsGrounded(const AABB& actor, const std::vector&lt;AABB&gt;& collidingActors, float extendedAmount)
{
	glm::vec2 newPos = glm::vec2(position.x, position.y + (size.y * 0.5f));
	glm::vec2 newSize = glm::vec2(size.x * 0.75, (size.y * 0.25f));

	AABB extendedActor = AABB::FromPositionSize(newPos, newSize);

	for (const auto& a : collidingActors)
	{
		if (aabbOverlap(extendedActor, a))
		{
			isGrounded = true;
			return true;
		}
	}

	isGrounded = false;
	return false;
}

bool Player::IsColliding(const AABB& a, const AABB& b, glm::vec2& outOverlap)
{
	float overlapX = glm::min(a.max.x - b.min.x, b.max.x - a.min.x);
	float overlapY = glm::min(a.max.y - b.min.y, b.max.y - a.min.y);

	if (overlapX > 0 && overlapY > 0)
	{
		outOverlap = glm::vec2(overlapX, overlapY);
		return true;
	}
	return false;
}

void Player::ResolveCollision(Actor* actor, const std::vector&lt;AABB&gt;& collidingActors)
{
	glm::vec2 overlap;

	AABB a = AABB::FromPositionSize(actor->position, actor->size);

	for (const auto& cA : collidingActors)
	{
		if (!IsColliding(a, cA, overlap))
		{
			continue;
		}

		float overlapArea = 0.0f;

		float overlapX = glm::max(0.0f, glm::min(a.max.x, cA.max.x) - glm::max(a.min.x, cA.min.x));
		float overlapY = glm::max(0.0f, glm::min(a.max.y, cA.max.y) - glm::max(a.min.y, cA.min.y));
		overlapArea = overlapX * overlapY;

		if (overlapArea > ((actor->size.x * actor->size.y) * 0.25f))
		{
			actor->velocity = glm::vec2(0);
			return;
		}


		if (overlap.x &lt; overlap.y) // checks smallest axis overlap - x or y?
		{
			if (actor->position.x &lt; cA.min.x)
			{
				actor->position.x -= overlap.x; // adjust position left
			}
			else
			{
				actor->position.x += overlap.x; // adjust position right
			}
			actor->velocity.x = 0;
		}
		else
		{
			if (actor->position.y &lt; cA.min.y)
			{
				actor->position.y -= overlap.y; // adjust position down
			}
			else
			{
				actor->position.y += overlap.y; // adjust position up
			}
			actor->velocity.y = 0;
		}
	}
}


void Player::Use(int i)
{
	int mousePosX = InputManager::Instance().MouseX();
	int mousePosY = InputManager::Instance().MouseY();

	glm::vec2 worldMousePos = Game::Instance().GetCamera()->ScreenToWorld(glm::vec2(mousePosX, mousePosY));

	glm::vec2 blockSize(16);

	glm::vec2 gridPos = glm::floor(worldMousePos / blockSize);

	std::cout &lt;&lt; "Mouse is over grid cell: " &lt;&lt; (int)gridPos.x &lt;&lt; ", " &lt;&lt; (int)gridPos.y &lt;&lt; std::endl;

	int gridWidth = Game::Instance().GetWorldGenerator()->WORLD_WIDTH;
	int gridHeight = Game::Instance().GetWorldGenerator()->WORLD_HEIGHT;

	if (gridPos.x >= 0 && gridPos.x &lt;= gridWidth && gridPos.y >= 0 && gridPos.y &lt;= gridHeight)
	{
		if (i == 0) // break
		{
			Game::Instance().GetWorldGenerator()->DestoryBlockAtPos((int)gridPos.x, (int)gridPos.y);
		}
		else if (i == 1) //place
		{
			Game::Instance().GetWorldGenerator()->CreateBlockAtPos((int)gridPos.x, (int)gridPos.y);
		}
	}
}

                        </code>
                    </pre>
                </div>

            </aside>
        </div>

        <!-- Code Example 7 -->
        <div class="code-info flex flex-col md:flex-row md:space-x-8 mt-8 relative">
            <section class="md:w-2/3 bg-neutral-900 bg-opacity-80 p-6 rounded-3xl relative">
                
                <button 
                class="toggleButton absolute top-10 right-10"
                onclick="toggleOverflow('code7pre-h', 'code7pre-cpp')">
                ⇅
                </button>
                <button 
                id="toggle-button7"
                class="toggleButton absolute top-10 right-20"
                onclick="toggleSections('code7-header', 'code7-cpp', 'toggle-button7')">
                header
                </button>

                <div id="code7-header" class="">
                    <pre id="code7pre-h" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#pragma once

#include "Actor.h"

class Block : public Actor
{
public:

	Block(glm::vec2 position);

	void Update() override;
	void Render() override;

	void Hit(int damage) override;

};
                        </code>
                    </pre>
                </div>

                <div id="code7-cpp" class="hidden">
                    <pre id="code7pre-cpp" class="p-4 rounded-3xl h-96 overflow-y-auto">
                        <code class="language-csharp">
#include "Block.h"
#include "Game.h"
#include "Player.h"
#include "TextureManager.h"

Block::Block(glm::vec2 position) 
	: Actor(position, glm::vec2(16))
{
	collisionType = ECollision_Type::Block;
}

void Block::Update()
{
	
}

void Block::Render()
{
	Actor::Render();

	TextureManager::Instance().Render("block_dirt", renderPosition.x, renderPosition.y, size.x, size.y, Game::Instance().GetRenderer());

}

void Block::Hit(int damage)
{
	// health check

	Destroy();
}
                        </code>
                    </pre>
                </div>

            </section>

            <!-- Sidebar -->
            <aside id="code7example" class="md:w-1/3 bg-neutral-900 bg-opacity-80 rounded-3xl p-6 my-8 md:my-0 h-fit">
                <h2 class="text-3xl font-semibold mb-4 text-green-500 shadow-md shadow-black p-2 text-center rounded-2xl">Block Class</h2>
                <p class="leading-8 py-1">
                    The Block class represent an in-game block and inherits from the Actor class.
                </p>
                <p class="leading-8 py-1">
                    Currently, it doesn't have any complex logic but is designed to be expanded upon later.
                </p>
                <p class="leading-8 py-1">
                    The Hit method will handle block damage, allowing blocks to have durability instead of being instantly destroyed.
                </p>
            </aside>    
        </div>

    </main>

    <script>
        function scrollToElement(id) {
            const element = document.getElementById(id);
            if (element) {
                element.scrollIntoView({ behavior: "smooth", block: "center" });
            }
        }
    </script>

    <script>
        function toggleOverflow(id1, id2) {
            const preElement1 = document.getElementById(id1);
            const preElement2 = document.getElementById(id2);

            if (preElement1.classList.contains("h-96") && preElement2.classList.contains("h-96")) 
            {
                preElement1.classList.remove("h-96");
                preElement2.classList.remove("h-96");

                preElement1.classList.add("h-fit");
                preElement2.classList.add("h-fit");
            } 
            else 
            {
                preElement1.classList.remove("h-fit");
                preElement2.classList.remove("h-fit");

                preElement1.classList.add("h-96");
                preElement2.classList.add("h-96");
            }
        }
    </script>

    <script>
        function toggleSections(id1, id2, id3) {
            const preElement1 = document.getElementById(id1);
            const preElement2 = document.getElementById(id2);
            const button = document.getElementById(id3);

            if (preElement1.classList.contains("hidden") && !preElement2.classList.contains("hidden")) 
            {
                preElement1.classList.remove("hidden");
                preElement2.classList.add("hidden");
                
                button.textContent = "header"
            } 
            else if (!preElement1.classList.contains("hidden") && preElement2.classList.contains("hidden"))
            {
                preElement2.classList.remove("hidden");
                preElement1.classList.add("hidden");
                
                button.textContent = "cpp"
            }
        }
    </script>

</body>
</html>
